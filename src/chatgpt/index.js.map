{"version":3,"sources":["../node_modules/delay/index.js","../src/chatgpt-api.ts"],"sourcesContent":["'use strict';\n\n// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst createDelay = ({clearTimeout: defaultClear, setTimeout: set, willResolve}) => (ms, {value, signal} = {}) => {\n\tif (signal && signal.aborted) {\n\t\treturn Promise.reject(createAbortError());\n\t}\n\n\tlet timeoutId;\n\tlet settle;\n\tlet rejectFn;\n\tconst clear = defaultClear || clearTimeout;\n\n\tconst signalListener = () => {\n\t\tclear(timeoutId);\n\t\trejectFn(createAbortError());\n\t};\n\n\tconst cleanup = () => {\n\t\tif (signal) {\n\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t}\n\t};\n\n\tconst delayPromise = new Promise((resolve, reject) => {\n\t\tsettle = () => {\n\t\t\tcleanup();\n\t\t\tif (willResolve) {\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\treject(value);\n\t\t\t}\n\t\t};\n\n\t\trejectFn = reject;\n\t\ttimeoutId = (set || setTimeout)(settle, ms);\n\t});\n\n\tif (signal) {\n\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t}\n\n\tdelayPromise.clear = () => {\n\t\tclear(timeoutId);\n\t\ttimeoutId = null;\n\t\tsettle();\n\t};\n\n\treturn delayPromise;\n};\n\nconst createWithTimers = clearAndSet => {\n\tconst delay = createDelay({...clearAndSet, willResolve: true});\n\tdelay.reject = createDelay({...clearAndSet, willResolve: false});\n\tdelay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);\n\treturn delay;\n};\n\nconst delay = createWithTimers();\ndelay.createWithTimers = createWithTimers;\n\nmodule.exports = delay;\n// TODO: Remove this for the next major release\nmodule.exports.default = delay;\n","import delay from 'delay'\nimport html2md from 'html-to-md'\nimport { type ChromiumBrowserContext, type Page, chromium } from 'playwright'\n\nexport class ChatGPTAPI {\n  protected _userDataDir: string\n  protected _headless: boolean\n  protected _markdown: boolean\n  protected _chatUrl: string\n\n  protected _browser: ChromiumBrowserContext\n  protected _page: Page\n\n  /**\n   * @param opts.userDataDir — Path to a directory for storing persistent chromium session data\n   * @param opts.chatUrl — OpenAI chat URL\n   * @param opts.headless - Whether or not to use headless mode\n   * @param opts.markdown — Whether or not to parse chat messages as markdown\n   */\n  constructor(\n    opts: {\n      /** @defaultValue `'/tmp/chatgpt'` **/\n      userDataDir?: string\n\n      /** @defaultValue `'https://chat.openai.com/'` **/\n      chatUrl?: string\n\n      /** @defaultValue `false` **/\n      headless?: boolean\n\n      /** @defaultValue `true` **/\n      markdown?: boolean\n    } = {}\n  ) {\n    const {\n      userDataDir = '/tmp/chatgpt',\n      chatUrl = 'https://chat.openai.com/',\n      headless = false,\n      markdown = true\n    } = opts\n\n    this._userDataDir = userDataDir\n    this._headless = !!headless\n    this._chatUrl = chatUrl\n    this._markdown = !!markdown\n  }\n\n  async init(opts: { auth?: 'blocking' | 'eager' } = {}) {\n    const { auth = 'eager' } = opts\n\n    if (this._browser) {\n      await this.close()\n    }\n\n    this._browser = await chromium.launchPersistentContext(this._userDataDir, {\n      headless: this._headless\n    })\n\n    this._page = await this._browser.newPage()\n    await this._page.goto(this._chatUrl)\n\n    // dismiss welcome modal\n    do {\n      const modalSelector = '[data-headlessui-state=\"open\"]'\n\n      if (!(await this._page.$(modalSelector))) {\n        break\n      }\n\n      try {\n        await this._page.click(`${modalSelector} button:last-child`, {\n          timeout: 1000\n        })\n      } catch (err) {\n        // \"next\" button not found in welcome modal\n        break\n      }\n    } while (true)\n\n    if (auth === 'blocking') {\n      do {\n        const isSignedIn = await this.getIsSignedIn()\n        if (isSignedIn) {\n          break\n        }\n\n        console.log(\n          'Please sign in to ChatGPT using the Chromium browser window and dismiss the welcome modal...'\n        )\n\n        await delay(1000)\n      } while (true)\n    }\n\n    return this._page\n  }\n\n  async getIsSignedIn() {\n    try {\n      const inputBox = await this._getInputBox()\n      return !!inputBox\n    } catch (err) {\n      // can happen when navigating during login\n      return false\n    }\n  }\n\n  async getLastMessage(): Promise<string | null> {\n    const messages = await this.getMessages()\n\n    if (messages) {\n      return messages[messages.length - 1]\n    } else {\n      return null\n    }\n  }\n\n  async getPrompts(): Promise<string[]> {\n    // Get all prompts\n    const messages = await this._page.$$(\n      '[class*=\"ConversationItem__Message\"]:has([class*=\"ConversationItem__ActionButtons\"]):has([class*=\"ConversationItem__Role\"] [class*=\"Avatar__Wrapper\"])'\n    )\n\n    // prompts are always plaintext\n    return Promise.all(messages.map((a) => a.innerText()))\n  }\n\n  async getMessages(): Promise<string[]> {\n    // Get all complete messages\n    // (in-progress messages that are being streamed back don't contain action buttons)\n    const messages = await this._page.$$(\n      '[class*=\"ConversationItem__Message\"]:has([class*=\"ConversationItem__ActionButtons\"]):not(:has([class*=\"ConversationItem__Role\"] [class*=\"Avatar__Wrapper\"]))'\n    )\n\n    if (this._markdown) {\n      const htmlMessages = await Promise.all(messages.map((a) => a.innerHTML()))\n\n      const markdownMessages = htmlMessages.map((messageHtml) => {\n        // parse markdown from message HTML\n        messageHtml = messageHtml.replace('Copy code</button>', '</button>')\n        return html2md(messageHtml, {\n          ignoreTags: [\n            'button',\n            'svg',\n            'style',\n            'form',\n            'noscript',\n            'script',\n            'meta',\n            'head'\n          ],\n          skipTags: ['button', 'svg']\n        })\n      })\n\n      return markdownMessages\n    } else {\n      // plaintext\n      const plaintextMessages = await Promise.all(\n        messages.map((a) => a.innerText())\n      )\n      return plaintextMessages\n    }\n  }\n\n  async sendMessage(message: string): Promise<string> {\n    const inputBox = await this._getInputBox()\n    if (!inputBox) throw new Error('not signed in')\n\n    const lastMessage = await this.getLastMessage()\n\n    await inputBox.click({ force: true })\n    await inputBox.fill(message, { force: true })\n    await inputBox.press('Enter')\n\n    do {\n      await delay(1000)\n\n      // TODO: this logic needs some work because we can have repeat messages...\n      const newLastMessage = await this.getLastMessage()\n      if (\n        newLastMessage &&\n        lastMessage?.toLowerCase() !== newLastMessage?.toLowerCase()\n      ) {\n        return newLastMessage\n      }\n    } while (true)\n  }\n\n  async close() {\n    await this._browser.close()\n    this._page = null\n    this._browser = null\n  }\n\n  protected async _getInputBox(): Promise<any> {\n    return this._page.$(\n      'div[class*=\"PromptTextarea__TextareaWrapper\"] textarea'\n    )\n  }\n}\n"],"mappings":"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","names":["require_delay","__commonJSMin","exports","module","randomInteger","minimum","maximum","createAbortError","error","createDelay","defaultClear","set","willResolve","ms","value","signal","timeoutId","settle","rejectFn","clear","signalListener","cleanup","delayPromise","resolve","reject","createWithTimers","clearAndSet","delay","options","import_delay","html2md","chromium","ChatGPTAPI","opts","userDataDir","chatUrl","headless","markdown","auth","modalSelector","delay","messages","a","messageHtml","message","inputBox","lastMessage","newLastMessage"]}